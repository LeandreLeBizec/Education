reg=lm(ht~circ, data=eucal)
resume=summary(reg)
resume
#Q4
lines(circ, predict(reg),col="red",lwd=3)
plot(reg$fitted.values,reg$residuals, ylim = c(-10,10), xlab="residus",ylab="valeur ajusté")
abline(h=0, col="blue")
abline(h=-2*resume$sigma, col="red")
abline(h=2*resume$sigma, col="red")
#a
# ecriture matricielle : Y = X*B + E
Y = ht
X0 <- c(rep(1, length(circ)))
X1 <- circ
X2 <- sqrt(circ)
X <- cbind(X0,X1,X2)
#b
# B = c(B0,B1,B2)
B = solve(t(X)%*%X)%*%t(X)%*%Y
#c
x <- circ
y <- B[1]+B[2]*x+B[3]*sqrt(x) #valeurs ajustées
e <- ht - y # residu
sigma <- sqrt(sum(e^2)/(length(e)-2-1))
#f
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q4
lines(circ, predict(reg),col="red",lwd=3)
lines(circ, predict(reg2), col="blue", lwd=3)
seq(0,100,1)
seh(0,100)
seq(0,100)
lines(seq(0,100), predict(reg2, data.frame(rcirc=sqrt((seq(0,100)))),col="Purple",lwd=3)
lines(seq(0,100), predict(reg2, data.frame(rcirc=sqrt((seq(0,100))),col="Purple",lwd=3)
lines(seq(0,100), predict(reg2, data.frame(rcirc=sqrt((seq(0,100))))),col="Purple",lwd=3)
lines(seq(0,100), predict(reg2, data.frame(sqrt(rcirc=(seq(0,100))))),col="Purple",lwd=3)
lines(seq(0,100), predict(reg2, data.frame(sqrt(circ=(seq(0,100))))), col="Purple", lwd=3)
#g
circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
grille=data.frame(circ)
grille2=cbind.data.frame(grille,sqrt(grille))
courbe=predict(reg2,new=grille2)
#Q1
eucal <- read.table("eucalyptus.txt", header = T)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q3
#modele : Yi = B_0 + B_1*x_i + e_i
# e_i erreurs résiduelles, indépendante et de même loi ~> N(0,sigma²)
#lm(y~x, data)
reg=lm(ht~circ, data=eucal)
resume=summary(reg)
resume
#Q4
lines(circ, predict(reg),col="red",lwd=3)
plot(reg$fitted.values,reg$residuals, ylim = c(-10,10), xlab="residus",ylab="valeur ajusté")
abline(h=0, col="blue")
abline(h=-2*resume$sigma, col="red")
abline(h=2*resume$sigma, col="red")
#a
# ecriture matricielle : Y = X*B + E
Y = ht
X0 <- c(rep(1, length(circ)))
X1 <- circ
X2 <- sqrt(circ)
X <- cbind(X0,X1,X2)
#b
# B = c(B0,B1,B2)
B = solve(t(X)%*%X)%*%t(X)%*%Y
#c
x <- circ
y <- B[1]+B[2]*x+B[3]*sqrt(x) #valeurs ajustées
e <- ht - y # residu
sigma <- sqrt(sum(e^2)/(length(e)-2-1))
#f
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
#g
lines(seq(0,100), predict(reg2, data.frame(sqrt(circ=(seq(0,100))))), col="Purple", lwd=3)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q4
lines(circ, predict(reg),col="red",lwd=3)
#g
lines(seq(0,100), predict(reg2, data.frame(sqrt(circ=(seq(0,100))))), col="Purple", lwd=3)
#g
lines(seq(0,100), predict(reg2, data.frame(sqrt(circ=(seq(0,100))))), col="blue", lwd=3)
#g
lines(seq(0,100), predict(reg2, data.frame(rcirc=(seq(0,100)))), col="blue", lwd=3)
#g
lines(seq(1,100), predict(reg2, data.frame(rcirc=(seq(1,100)))), col="blue", lwd=3)
rcric
eucal2$rcirc
eucal2$rcirc=seq(1,100)
eucal2$rcirc=seq(1,100)
seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
#g
lines(seq(1,100), predict(reg2, data.frame(circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)), col="blue", lwd=3)
#g
lines(seq(1,100), predict(reg2, data.frame(circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100))), col="blue", lwd=3)
#g
lines(seq(1,100), predict(reg2, data.frame(circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100))), col="blue", lwd=3)
#g
lines(seq(1,100), predict(reg2, data.frame(circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100))), col="blue", lwd=3)
#g
lines(seq(1,100), predict(reg2, data.frame(seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100))), col="blue", lwd=3)
#g
lines(seq(1,100), predict(reg2, data.frame(seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100))), col="blue", lwd=3)
length(seq(1,100))
length(seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100))
predict(reg2, data.frame(seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)))
predict(reg2, data.frame(circ=40))
predict(reg2, data.frame(circ=40, rcirc=sqrt(40)))
predict(reg, circ = 40)
predict(reg, data.frame(circ=40))
predict(reg2, data.frame(circ=40))
predict(reg2, data.frame(circ=40, rcirc=sqrt(40)))
plot(rcirc, ht)
plot(sqrt(circ), ht)
lines(circ, predict(reg2), col = "blue", lwd=3)
lines(sqrt(circ), predict(reg2), col = "blue", lwd=3)
reg2=lm(ht~circ+rcirc, data=eucal2)
resume2=summary(reg2)
resume2
predict(reg2, data.frame(circ = 40))
reg2=lm(ht~eucal$circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
predict(reg2, data.frame(circ = 40))
lines(sqrt(circ), B[1]+B[2]*x+B[3]*sqrt(x), col = "blue", lwd=3)
plot(sqrt(circ), ht)
lines(sqrt(circ), B[1]+B[2]*x+B[3]*sqrt(x), col = "blue", lwd=3)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q4
lines(circ, predict(reg),col="red",lwd=3)
lines(circ, B[1]+B[2]*x+B[3]*sqrt(x), col="blue", lwd=3)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
grille=data.frame(circ)
grille2=cbind.data.frame(grille,sqrt(grille))
courbe=predict(regmult,new=grille2)
matlines(circ,cbind(courbe),col="red",lwd=3)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
grille=data.frame(circ)
grille2=cbind.data.frame(grille,sqrt(grille))
courbe=predict(reg2,new=grille2)
matlines(circ,cbind(courbe),col="red",lwd=3)
plot(sqrt(circ), ht)
lines(sqrt(circ), predict(reg2), col = "blue", lwd=3)
plot(sqrt(circ), ht)
plot(sqrt(circ), ht)
plot(circ, ht)
#Q1
eucal <- read.table("eucalyptus.txt", header = T)
attach(eucal)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q3
#modele : Yi = B_0 + B_1*x_i + e_i
# e_i erreurs résiduelles, indépendante et de même loi ~> N(0,sigma²)
#lm(y~x, data)
reg=lm(ht~circ, data=eucal)
resume=summary(reg)
resume
#B0 = 9.037476
#B1 = 0.257138
#Q4
lines(circ, predict(reg),col="red",lwd=3)
plot(reg$fitted.values,reg$residuals, ylim = c(-10,10), xlab="residus",ylab="valeur ajusté")
abline(h=0, col="blue")
abline(h=-2*resume$sigma, col="red")
abline(h=2*resume$sigma, col="red")
# non homoscédastique
#Q5
#a
# ecriture matricielle : Y = X*B + E
Y = ht
X0 <- c(rep(1, length(circ)))
X1 <- circ
X2 <- sqrt(circ)
X <- cbind(X0,X1,X2)
#b
# B = c(B0,B1,B2)
B = solve(t(X)%*%X)%*%t(X)%*%Y
#c
x <- circ
y <- B[1]+B[2]*x+B[3]*sqrt(x) #valeurs ajustées
e <- ht - y # residu
sigma <- sqrt(sum(e^2)/(length(e)-2-1))
#d
#e
plot(sqrt(circ), ht)
lines(sqrt(circ), predict(reg2), col = "blue", lwd=3)
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~eucal$circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
plot(sqrt(circ), ht)
lines(sqrt(circ), predict(reg2), col = "blue", lwd=3)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
grille=data.frame(circ)
grille2=cbind.data.frame(grille,sqrt(grille))
courbe=predict(reg2,new=grille2)
matlines(circ,cbind(courbe),col="red",lwd=3)
courbe=predict(reg2,new=grille2)
B[1]+B[2]*40+B[3]*sqrt(40)
eucal <- read.table("eucalyptus.txt", header = T)
attach(eucal)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q3
#modele : Yi = B_0 + B_1*x_i + e_i
# e_i erreurs résiduelles, indépendante et de même loi ~> N(0,sigma²)
#lm(y~x, data)
reg=lm(ht~circ, data=eucal)
resume=summary(reg)
resume
#B0 = 9.037476
#B1 = 0.257138
#Q4
lines(circ, predict(reg),col="red",lwd=3)
plot(reg$fitted.values,reg$residuals, ylim = c(-10,10), xlab="residus",ylab="valeur ajusté")
abline(h=0, col="blue")
abline(h=-2*resume$sigma, col="red")
abline(h=2*resume$sigma, col="red")
# non homoscédastique
#Q5
#a
# ecriture matricielle : Y = X*B + E
Y = ht
X0 <- c(rep(1, length(circ)))
X1 <- circ
X2 <- sqrt(circ)
X <- cbind(X0,X1,X2)
#b
# B = c(B0,B1,B2)
B = solve(t(X)%*%X)%*%t(X)%*%Y
#c
x <- circ
y <- B[1]+B[2]*x+B[3]*sqrt(x) #valeurs ajustées
e <- ht - y # residu
sigma <- sqrt(sum(e^2)/(length(e)-2-1))
#d
#e
#f
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~eucal$circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
#g
plot(sqrt(circ), ht)
lines(sqrt(circ), predict(reg2), col = "blue", lwd=3)
lines(seq(0,70,0.5),exp(predict(reg3,newdata = data.frame(Length2=(seq(0,70,0.5))^2))),col="Purple",lty=2)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
result <- B[1]+B[2]*x+B[3]*sqrt(x)
x = 1
result = B[1]+B[2]*x+B[3]*sqrt(x)
x = c(1,2)
result = B[1]+B[2]*x+B[3]*sqrt(x)
x = c(1:100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
x = seq(1,100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(circ, result, col="red", lwd=3)
circ
circ(seq(1,100))
circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
lines(circ, result, col="red", lwd=3)
circ
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
circ=seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(x, result, col="red", lwd=3)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(x, result, col="red", lwd=3)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
plot(circ, ht)
#Q1
eucal <- read.table("eucalyptus.txt", header = T)
attach(eucal)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q3
#modele : Yi = B_0 + B_1*x_i + e_i
# e_i erreurs résiduelles, indépendante et de même loi ~> N(0,sigma²)
#lm(y~x, data)
reg=lm(ht~circ, data=eucal)
resume=summary(reg)
resume
#B0 = 9.037476
#B1 = 0.257138
#Q4
lines(circ, predict(reg),col="red",lwd=3)
plot(reg$fitted.values,reg$residuals, ylim = c(-10,10), xlab="residus",ylab="valeur ajusté")
abline(h=0, col="blue")
abline(h=-2*resume$sigma, col="red")
abline(h=2*resume$sigma, col="red")
# non homoscédastique
#Q5
#a
# ecriture matricielle : Y = X*B + E
Y = ht
X0 <- c(rep(1, length(circ)))
X1 <- circ
X2 <- sqrt(circ)
X <- cbind(X0,X1,X2)
#b
# B = c(B0,B1,B2)
B = solve(t(X)%*%X)%*%t(X)%*%Y
#c
x <- circ
y <- B[1]+B[2]*x+B[3]*sqrt(x) #valeurs ajustées
e <- ht - y # residu
sigma <- sqrt(sum(e^2)/(length(e)-2-1))
#d
#e
#f
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~eucal$circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
#g
plot(sqrt(circ), ht)
lines(sqrt(circ), predict(reg2), col = "blue", lwd=3)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(x, result, col="red", lwd=3)
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(x, result, col="blue", lwd=3)
result = predict(reg2)
result = predict(reg2, data.frame(x))
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(x, result, col="blue", lwd=3)
#Q1
eucal <- read.table("eucalyptus.txt", header = T)
attach(eucal)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q3
#modele : Yi = B_0 + B_1*x_i + e_i
# e_i erreurs résiduelles, indépendante et de même loi ~> N(0,sigma²)
#lm(y~x, data)
reg=lm(ht~circ, data=eucal)
resume=summary(reg)
resume
#B0 = 9.037476
#B1 = 0.257138
#Q4
lines(circ, predict(reg),col="red",lwd=3)
plot(reg$fitted.values,reg$residuals, ylim = c(-10,10), xlab="residus",ylab="valeur ajusté")
abline(h=0, col="blue")
abline(h=-2*resume$sigma, col="red")
abline(h=2*resume$sigma, col="red")
# non homoscédastique
#Q5
#a
# ecriture matricielle : Y = X*B + E
Y = ht
X0 <- c(rep(1, length(circ)))
X1 <- circ
X2 <- sqrt(circ)
X <- cbind(X0,X1,X2)
#b
# B = c(B0,B1,B2)
B = solve(t(X)%*%X)%*%t(X)%*%Y
#c
x <- circ
y <- B[1]+B[2]*x+B[3]*sqrt(x) #valeurs ajustées
e <- ht - y # residu
sigma <- sqrt(sum(e^2)/(length(e)-2-1))
#d
#e
#f
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~eucal$circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
#g
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(x, result, col="blue", lwd=3)
#Q1
eucal <- read.table("eucalyptus.txt", header = T)
attach(eucal)
#Q2
# on veut expliquer la hauteur grâce à la circonférence de l'arbre
# variable à expliquer : hauteur (y)
# variable explicative : circonférence (x)
plot(circ, ht)
#Q3
#modele : Yi = B_0 + B_1*x_i + e_i
# e_i erreurs résiduelles, indépendante et de même loi ~> N(0,sigma²)
#lm(y~x, data)
reg=lm(ht~circ, data=eucal)
resume=summary(reg)
resume
#B0 = 9.037476
#B1 = 0.257138
#Q4
lines(circ, predict(reg),col="red",lwd=3)
plot(reg$fitted.values,reg$residuals, ylim = c(-10,10), xlab="residus",ylab="valeur ajusté")
abline(h=0, col="blue")
abline(h=-2*resume$sigma, col="red")
abline(h=2*resume$sigma, col="red")
# non homoscédastique
#Q5
#a
# ecriture matricielle : Y = X*B + E
Y = ht
X0 <- c(rep(1, length(circ)))
X1 <- circ
X2 <- sqrt(circ)
X <- cbind(X0,X1,X2)
#b
# B = c(B0,B1,B2)
B = solve(t(X)%*%X)%*%t(X)%*%Y
#c
x <- circ
y <- B[1]+B[2]*x+B[3]*sqrt(x) #valeurs ajustées
e <- ht - y # residu
sigma <- sqrt(sum(e^2)/(length(e)-2-1))
#d
#e
#f
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~eucal$circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
#g
plot(circ, ht)
lines(circ, predict(reg),col="red",lwd=3)
x = seq(min(eucal[,"circ"]),max(eucal[,"circ"]),length=100)
result = B[1]+B[2]*x+B[3]*sqrt(x)
lines(x, result, col="blue", lwd=3)
solve(t(X)%*%X)
solve(t(X)%*%X)[0,0]
solve(t(X)%*%X)[1,1]
solve(t(X)%*%X)[1,1]*sigma^2
B0 = sqrt(solve(t(X)%*%X)[1,1]*sigma^2)
B1 = sqrt(solve(t(X)%*%X)[2,2]*sigma^2)
B2 = sqrt(solve(t(X)%*%X)[3,3]*sigma^2)
eucal2 <- cbind.data.frame(eucal,rcirc=sqrt(eucal[,"circ"]))
reg2=lm(ht~eucal$circ+eucal2$rcirc, data=eucal2)
resume2=summary(reg2)
resume2
#e
# racine carré de la circonférence influe sur la hauteur ?
# hypothese : H0 { B2 = 0 } vs H1 { B2 != 0}
# stat de test et loi  : sous H0, T0 = B2 / sigma_B2
T0 = B[2] / B2
help(qt)
qt(0.975, 1)
length(e)
-2-1
qt(0.975, 1426)
